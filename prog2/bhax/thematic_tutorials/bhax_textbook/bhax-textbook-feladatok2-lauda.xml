<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Lauda!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
<!--
    <section>
        <title>Port scan</title>

        <para>
            Megoldás forrása: <link xlink:href="https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/scan.java">https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/scan.java</link>               
        </para>
<para>
A megadott program nem csinál mást mint visszaad egy listát a 0-tól 1024-ig tartó TCP kapukról, hogy az adott időben melyik volt használva és melyik nem. Ennek a megvalósítására kivételkezelést használ és ez lenne a lényeg, hogy miért ezt használja. De először nézzük a programot röviden.
</para>
<programlisting language='java'>
<![CDATA[        for(int i=0; i<1024; ++i)
            
            try {
                
                java.net.Socket socket = new java.net.Socket(args[0], i);
                
                System.out.println(i + " figyeli");
                
                socket.close();
                
            } catch (Exception e) {
                
                System.out.println(i + " nem figyeli");]]>
</programlisting>
<para>
A fenti programrész igazából az egész main function és igazán egyszerű megvalósítás. Az hogy 0-tól 1024-ig nézzük a kapukat az egyértemű, hogy egy for cikluson belűl lesz megoldva. Viszont egy try catch blokkban található maga a socket létrehozása és azt látjuk, ha létre tudja hozni, akkor használatban van, ha pedig akármilyen hiba exception jön akkor nem figyelnek.
</para>
<para>
Ha tudni akarjuk, hogy pontosan miért fog mőködni ez a megoldás akkor egy gyors kereséssel meg is lehet találni az oracle oldalán, hogy a függvény mikor dobhat kivételt és egy rövid leírást is.
</para>
<programlisting language='java'>
<![CDATA[public Socket(String host, int port)]]>
</programlisting>
<para>
Röviden fogalmazva IOException-t fog dobni ha nem tud létrehozni egy socketet. Vagy másképpen fogalmazva, ha nincs nyitva port, akkor nem fogja tudni létrehozni a socketet és egy exceptionnel lep meg inkább minket. Ami rögtön meg is magyaráza, hogy miért try catch blokkban van az egész. De ezen kívűl az is kiderűl, hogy ha a host nevét null-ként adjuk át akkor a loopback címmel fog alapértelmezetten dolgozni. És ezzel a módszerrel el is kezdhetünk nyitott portok után keresni akár biztonsági okokból akár nem.
</para>
    </section>        
              
    <section>
        <title>AOP</title>

        <para>
            Megoldás forrása: <link xlink:href="https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/aop.aj">https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/aop.aj</link>               
        </para>
<para>
Aspect oriented programming nem más mint egy olyan programozási módszer, ami a modularitásra épül és ennek segítségével anélkül lehet új viselkedést hozzáadni a már meglévő kódokhoz, hogy azokat módosítanánk. Ezt pointcutok és joint pointok segítségével éri el. Lényegében amire ezt lehet használni az főként debuging célok. Mivel példáúl jól lehet vele logolni, hogy egy függvény mondjuk hányszor lett megírva. De az is igaz, hogy új viselkedést is hozzá lehet adni mint példáúl ennél a feladatnál.
</para>
<para>
A bináris fákat három féleképpen lehet bejárni. Inorder, postorder és preorder sorrendben. Ezek az elnevezések arra utalnak, hogy milyen sorrendben vannak feldoldolgozva a gyökér elemek a gyerekekhez képest. És mivel ez egy rekurzív függvényhívás lesz, vagyis kettő így elég egyszerű megvalósítani is.
</para>
<para>
Először megadjuk, hogy hol szeretnénk egy pointcutot létrehozni. Lényegében ezzel adjuk meg, hogy hol szeretnénk beleszólni a program működésébe.
</para>
<programlisting language='java'>
<![CDATA[	public pointcut travel(LZWBinaryTree.Node n, PrintWriter os) 
	: call(public void LZWBinaryTree.printTree(LZWBinaryTree.Node, PrintWriter)) && args(n,os);]]>
</programlisting>
<para>
Ezután megadjuk, hogy mit szeretnénk csinálni. Mi most a poncut után. Azaz akkor amikor már lefutott a függvény az alábbi kis kódrészletet szeretnénk lefutatni, ami nem tesz mást mint elkezdi a rekurziót az inorder és postorder bejárásokhoz és kiírja a tartalmukat egy fájlba.
</para>
<programlisting language='java'>
<![CDATA[    after(LZWBinaryTree.Node n, PrintWriter os) throws FileNotFoundException : travel(n, os)
    {
    	inOrder(n,new PrintWriter("in-order.txt"));
    	depth = 0;
    	postOrder(n,new PrintWriter("post-order.txt"));
    }]]>
</programlisting>
<para>
És végül itt a két függvény. Ezekben nincs semmi különös. Mivel rekúrzívak így egyszer csak be kell indítani őket és onnantól kezdve végigmennek a fán.
</para>
<programlisting language='java'>
<![CDATA[
    public void inOrder(LZWBinaryTree.Node n, PrintWriter p)
    {
    	if (n != null)
        {
            ++depth;
            for (int i = 0; i < depth; ++i)
                p.print("");
            p.print(n.getValue () + "(" + depth + ")\n");
            inOrder (n.getLeftChild (), p);
            inOrder (n.getRightChild (), p);
            depth;
        }
    }
    public void postOrder(LZWBinaryTree.Node n, PrintWriter p)
    {
    	if (n != null)
        {
            ++depth;
            postOrder (n.getLeftChild (), p);
            postOrder (n.getRightChild (), p);
            for (int i = 0; i < depth; ++i)
                p.print("");
            p.print(n.getValue () + "(" + depth + ")\n");
            depth;
        }
    }]]>
</programlisting>
    </section>

    <section>
        <title>Junit teszt</title>

        <para>
            Megoldás forrása: <link xlink:href="https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/LZWBinFaTest.java">https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/LZWBinFaTest.java</link>               
        </para>
<para>
A programozóknak szükségük van eszközökre amikkel könnyebbé lehet tenni a debugging folyamatot vagy magát azt, hogy egy programot, hogyan tudnak tesztelni. Ezek még egy kisebb programnál nem okoznak gondot, de mikor már nagyobb projektről van szó, akkor már elég bonyolulttá tud válni a dolog. Ezt a tesztelési fázist szeretné megkönnyíteni a junit. Ennek segítségével olyan programokat tudunk írni java nyelven, amivel tesztelni tudjuk java osztályainkat és ha nem is tudjuk rögtön, hogy hol a hiba legalább arra választ kaphatunk, hogy mondjuk melyik osztályban vagy függvényben kell keresni.
</para>
<para>
Junit kicsit olyan mint a AOP egy kicsit átgondolása mivel ugyanúgy lehetőség van tesztelésre anélkül, hogy a forráskódot módosítanánk. Példáúl lehetőség van tageket megadni, amikkel lehet szűrni a @Tag megadásával. Vagy olyan függvényt írni, ami lefog futni még maga teszt előtt vagy a teszt után @BeforeAll és @AfterAll formájában, így példáúl a teszt előtt bekérhetjük az adatokat és a végén mondjuk összegezetjük, hogy mi lett az eredménye. Vagy akár minden teszt medódus előtt vagy után is csinálhatunk ilyet, ha logolni szeretnénk példáúl valamit. De akár egy teszt medusnak vagy osztálynak meg is modhatjuk, hogy most őt nem szeretnénk lefutattni. És még lehetne sorlni, hogy miket lehet vele csinálni, de inkább nézzük magát a feladatot.
</para>
<para>
Szóval ha megírtunk egy osztáyt, akkor igazából el kell kezdenünk goldolkozni, hogy milyen bemenetre milyen végeredmény várható és ezt kell összehasonlítani azzal, hogy valójában mit kapunk. Erre önmagában nem szükséges a junit, de ha használjuk, akkor nem fogjuk összeszemetetlni a saját kódunkat. Tehát binfa esetén megnézzük, hogy egy bemenetre milyen fát kéne kapunk és milyen értékeinek kéne lennie.
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/lzwpapir.jpeg" scale="70" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
Most hogy megvan, hogy egy adott bemenetre milyen értékeket kéne adni elkezdhetjük megírni magát a teszt programot. De még előtte fontos megjegyezni, hogy érdemes olyan bemenetet választani, ami problémás lehet vagy érdemes tesztelni. Nyílván itt a binfánál nincs olyan nagy választék, de nagyobb projekteknél elképzelhető, hogy több különböző bemenetet is tesztelni kell.
</para>
<programlisting language='java'>
<![CDATA[public class LZWBinFaTest {
    LZWBinFa binfa = new LZWBinFa();
    
    @Test
    public void testHozzarendel() {
        char[] minta = "01111001001001000111".toCharArray();
        
        for(char betu: minta ){
            binfa.hozzarendel(betu);
        }
        
        assertEquals(4, binfa.getMelyseg());
        assertEquals(2.75, binfa.getAtlag(), 0.01);
        assertEquals(0.957427, binfa.getSzoras(), 0.000001);
    }    
    
}]]>
</programlisting>
<para>
A fenti program pedig teszteli a bemenetet olyan módon, hogy létrehozunk egy elemét a binfa osztálynak. Azután belerakjuk a már papíron felhasznált bemenetet és megnézzük, hogy maga az értékek, amiket kapnunk kell azok mennyire egyeznek meg azzal, amit kapnunk kéne. Érdemes megjegyezni, hogy milve az átlag és a szórás azok nem egész típusok ezért kerekítés miatt lehet nem pont ugynazt az eredményt kapjuk, mivel véges a memória. Példáúl 1 / 3 * 3 nem lesz egyenlő eggyel ugyanezen ok miatt és ezért adtunk meg egy kis toleranciát ha elófordúlna ilyesmi.
</para>
    </section>

    <section>
        <title>OSCI</title>

        <para>
            Megoldás forrása: <link xlink:href="https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/OSCI.cpp">https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/OSCI.cpp</link>               
        </para>
<para>
Leírás szerint maga a program annyi, hogy egy egyszrű opengl-es megjelenítő és egy kocsit lehet rajta irányítani. Viszont ez az opengl-es megjelenítés annyira nem volt kötelező legalábbis azokból, amit én hallotam és meg lehetet oldani unityben is. Viszont ha unityben csináltam volna akkor már régen kész lennék vele és nem lenne kihívás. Szóval én szeretem ha fáj és ezért én a leírásból indultam ki és a terv az, hogy egy 2d kocsit lehessen irányítani.
</para>
<para>
Még maga a feladat leírása előtt szeretném kifejezni, hogy mennyire hálás vagyok azért, hogy hogyan is működik az opengl. Szóval maga a grafikus driver implementlja a dolgokat és nyílván különboző gyártók között lesz eltérés. Már csak azért is mert maga az opengl nem köti ki mindennek, hogy hogyan is kéne pontosan működnie. Példáúl adott a lenti hiba. Amit csak akkor kap meg az ember, ha külön visszakéri a hibákat. De a lényeg, hogy van ott egy szép hosszú sor, ami vonza az ember tekintetét és úgy voltam vele, hogy hát megnézem mi lenne rá a megoldás. Amire megkaptam, hogy a vertex és fragment shadert felcseréltem. Amit hosszas nézegetés után sem értettem mert nem. Majd később egy másik eszköznél ugyanaz a program a hiba első sorát adta vissza, amiből egyértelmű, hogy csak pancser vagyok és elírtam egy változót. 
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/osci.png" scale="80" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
Így egy rövid bevezető után végre elkezdhetünk beszélni magáról a programról.
</para>
<para>
Szóval maga opengl segítségével kéne megjeleníteni pár objectet és jobb esetben még interaktálni is lehet velük. Én ehhez a feladathoz <link xlink:href="https://www.glfw.org/">GLFW</link> könyvtárat használtam, ami nem más mint ad egy crossplatform supportot az opengl-hez. Tehát ha nem csak windowson szeretném hogy fusson, akkor csak az adott platformra kell lefordítani. Érdemes még azt is megjegyzeni, hogy windows esetében opengl1.1 az utolsó kiadott verzió, ami kicsit régi. Valamint azt érdemes megjegyezni, hogy opengl használata során mi nem látjuk magát a forráskódokat csak függvényeket használunk és maga az utasítássorozat a grafikus kártya driverében van implementálva. Ezért igazából ha újabb verziót szeretnénk használni windowson mint opengl1.1 ezért szükségünk lesz még egy opengl extension libraryre, ahonnan megkapjuk a függvényeket. Ehhez én <link xlink:href="http://glew.sourceforge.net/">GLEW</link>-t használtam, ami szintén cross-platform.
</para>
<para>
Szóval le vannak tudva a függvénykönyvtárak és mostmár elkezdhetjük magát a programot írni. Kiindulási alapnak GLFW oldalán meg lehet találni egy kódot ami készít egy adott felbontású ablakot.
</para>
<programlisting language='c++'>
<![CDATA[#include <GLFW/glfw3.h>

int main(void)
{
    GLFWwindow* window;

    /* Initialize the library */
    if (!glfwInit())
        return -1;

    /* Create a windowed mode window and its OpenGL context */
    window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    /* Make the window's context current */
    glfwMakeContextCurrent(window);

    /* Loop until the user closes the window */
    while (!glfwWindowShouldClose(window))
    {
        /* Render here */
        glClear(GL_COLOR_BUFFER_BIT);

        /* Swap front and back buffers */
        glfwSwapBuffers(window);

        /* Poll for and process events */
        glfwPollEvents();
    }

    glfwTerminate();
    return 0;
}]]>
</programlisting>
<para>
Itt nyíván meg kell adni include directorinak azt, ahova pakoltuk a GLFW és a nekünk megfelelő visual studio verzióval rendeklehóző mappát a linkernek. Valamint dependeciesnél magát az opengl32.lib-et és eldöntjük, hogy hogyan szeretnénk linkelni a GLFW-t, mivel nincs miért ne statikusan linkelni, így megadhatjuk a megfelelő .lib fájlt.
</para>
<para>
Ezek után már tudunk is használni legacy opengl kódokat. Amik így visszagondolva elég egyszerűek. Példáúl egy háromszög rajzolása.
</para>
<programlisting language='c++'>
<![CDATA[        glBegin(GL_TRIANGLES);
        glVertex2f(0, 0);
        glVertex2f(1, 0);
        glVertex2f(0, 1);
        glEnd();
]]>
</programlisting>
<para>
Modern opengl-ben ez kicsit bonyolúltabban néz ki. És mivel szeretem ha fáj ezért miért is ne próbálkoznék azzal. Szóval ehhez előbb includolni kell GLEW-t és máris tudunk modern opengl függvényeket használni. Ha statikusan szeretnénk linkelni, akkor viszont definiálnunk kell GLEW_STATIC-ot. Includolásnál fontos, hogy még GLFW előtt includoljuk valamint akkor kell inicializálni mikor már van egy valid opengl context. 
</para>
<para>
Maga drawcall csak ennyi, ami egy kicsit megtévesztő mivel kell neki egy kis előkészítés.
</para>
<programlisting language='c++'>
<![CDATA[glDrawArrays(GL_TRIANGLES, 0, 3);]]>
</programlisting>
<para>
Modern opengl esetében két féleképpen lehet előkészíteni a dolgokat. Előszor egy VAO kell és ha szerenénk, akkor már elementeket rajzolunk. Index buffereknek annyi szerepe van, hogy ne ismételjünk vertexet feleslegesen a memóriában, hanem adjuk meg magukt a pontokat és egy indexeket tartalmazó tömbben megtalálhtó, hogy hogyan rajzolja ki háromszögekből az adott objektumot.
</para>
<programlisting language='c++'>
<![CDATA[
	unsigned int buffer;
	glGenBuffers(1, &buffer);
	glBindBuffer(GL_ARRAY_BUFFER, buffer);
	glBufferData(GL_ARRAY_BUFFER, 6 * sizeof(float), positions, GL_STATIC_DRAW);

	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), 0);]]>
</programlisting>
<para>
Szóval ha a fenti kódot beírtuk akkor még lehetséges, hogy csak egy fekete képet látunk, mivel nincs shaderünk és ezt a driverünk dönti el, hogy szeretne nekünk adni egy alap shadert vagy nem ad és csak egy fekete képet látunk. A fenti kód egyszerűen nem csinál mást mint, létrehoz egy buffert, ami positions tömb elemeit tartalmaza. Csak azért néz ki, így mivel meg is adjuk, hogy milyen bufferről van szó, mekkora a mérete, miből és statikusat szeretnénk-e vagy dinamikusat példáúl. Ezen kívűl előfordúlhat, hogy nem csak a vertex pozicíóit tároljuk a VAO-ban ezért azt is meg kell adni, hogy hogyan épül fel a vertexattribpointer segítségével. Ez olyanokat tartalmaz, mint hgoy milyen a típusa, normalizált-e hány vertex tartozik egy pontot, mennyi a pontok leírása közötti távolság. Ezután pedig a VRAM-ban lesz tárolva az adatunk.
</para>
<para>
Ez mind jó egy háromszög esetében, de bonyolúltabb alakzatok is háromszögekből lesznek felépítve és szeretnénk elkerűlni a pontok duplikálását. Erre pedig egy index buffert kell létrehozni, ahol megadjuk, hogy melyik indexű vertex következik.
</para>
<programlisting language='c++'>
<![CDATA[	unsigned int ibo;
	glGenBuffers(1, &ibo);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6  * sizeof(unsigned int), indices, GL_STATIC_DRAW);]]>
</programlisting>
<para>
Ezután már a gldrawelemnts-el szertnénk kirajzolni, mivel az index bufferrel dolgozik.
</para>
<programlisting language='c++'>
<![CDATA[glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);]]>
</programlisting>
<para>
Ezek után érdemes shadert írni. Már csak azért mert nincs megszabva, hogy ha nincs akkor kapunk egy alap shadert, ami azt következi, hogy nem fogunk semmit se látni abból, amit ki szeretnénk írni. Valamint ha a négyzetre rárakunk egy textúrát, ahhoz megint szükségünk van shaderre. 2 féle shader létezik vertex és fragment shader. Az előbbi a vertex pontoknál ényeges, míg az utóbbi a kitöltendő pixeleknél.
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/shader.png" scale="150" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
Maga a kocsi mozgása, billentyű letésre törtne, amihez csak le kell kérni az adott billentyű leütéseket és megnézni, mely gomb került leütésre. Viszont ezen még lenne mit javítani.
</para>
<programlisting language='c++'>
<![CDATA[static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
	if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
		glfwSetWindowShouldClose(window, GLFW_TRUE);
	if (key == GLFW_KEY_W)
	{
		std::cout << "w\n";
		translation.x += sin(angle) * 0.01f;
		translation.y += cos(angle) * 0.01f;
	}

	if (key == GLFW_KEY_S )
	{
		std::cout << "s\n";
		translation.x -= sin(angle) * 0.01f;
		translation.y -= cos(angle) * 0.01f;
	}

	if (key == GLFW_KEY_D)
	{
		std::cout << "d\n";
		angle -= 5.0f;
	}

	if (key == GLFW_KEY_A)
	{
		std::cout << "a\n";
		angle += 5.0f;
	}
}]]>
</programlisting>
    </section>
-->
<section>
<title></title>
<para>Az OSCI3 passzolása ide is jönne. mivel a többi feladat kidolgozását gyengének ítéltem meg és nem lett idő javítani azokat, ezért az xml-ben kikommentelve megtalálható.</para>
</section>
    <section>
        <title>OSCI3</title>

        <para>
            Megoldás forrása: <link xlink:href="https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/OSCI3.cpp">https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/OSCI3.cpp</link>, <link xlink:href="https://github.com/DonatPataki/University/tree/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/opengl">https://github.com/DonatPataki/University/tree/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/openglp</link>               
        </para>
<para>
Maga a feladat leírása azt mondta, hogy rajzoljuk ki opengl-ben Debrecen utcáit. Vagyis pontosabban csak utakat jelenítsen meg és nekem valahogy ez csapódott hozzá alapból és ezt kezdtem el csinlálni.
</para>
<para>
Még maga a feladat leírása előtt annyit, megjegyeznék, hogy maga a program működik, de annyi limitációval rendelkezik, hogy magát az utcák pontjainak koordinátái és az indexek és, hogy mennyit rajzoljon az a stacken tárolódik. Ez alapvetően nem olyan nagy baj, de egy ilyen programnál, elég hamar túl lehet lépni azt a memóriahatárt, amit a stacken lehet tárolni. Ezért itt csak az első 16 út van kirajzolva, olyan sorrendben, ahogy az osm tárolta. De lényegében ez csak egy tanuló program, hogy hogyan is jutottam el addig, hogy kirajzolja.
</para>
<para>
Szóval maga az alapelképzelés az volt, hogy Debrecen térképét meg lehet kapni xml formában OSM oldaláról és én onnan saját programot írva kiszedem a nekem hasznos információkat példáúl az utcák koordinátáit és már csak ki kell rajzolni opengl-ben. És ilyenkor jönnek azok a finomságok, hogy az OSM oldaláról nem lehet letölteni mert node limit van. Ekkor nem estem kétségbe és megnéztem hol van tükrözve az adat, hogy le tudjam majd onnan tölteni. Így kerültem a geofabrik oldalára, ahol le kicsit túl lőttem a célon és letöltöttem egész Magyarországra vonatkozó adatokat. Ami kicsomagolás után 3 gigát nyomott...  És volt vele egy kicsi gond...
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/size.png" scale="100" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
Szóval hogy elérte a 2 GB-s limitet és ezért nem lehet ilyen módon megnyitni. De én nem esetem kétségbe, mivel nem az a fajta ember vagyok és letöltöttem egy olyan programot, ami tud nagyobb fájlokat is kezelni és láttam 54534701 szép sort, amiből elég sokmindent ki tudtam szedni hasszas nézegetés után, de azért mégiscsak kicsit túlzás, hogy ezzel dolgozzak.
</para>
<para>
Ekkor már mondhatni, kicsit visszaesett bátorsággal kezdtem el keresgélni, hogy hogyan is lehetne leszűrni az OSM adatait. És mint egy isteni sugallat hatására találtam meg az <link xlink:href="https://overpass-turbo.eu/">overpass turbo</link> nevezetű oldalt, ami OSM adatokkal dolgozik és lehet szűrni querry segítségével. Továbbá a visszaadot xml-t le lehet tölteni. Ahol örömben az alőbbi querryvel ki is szedtem a az utakat. És így már csak egy kis csinos 6 megás fájllal kell dolgozni.
</para>
<programlisting>
<![CDATA[area[name="Debrecen"][type=boundary]->.a;
(
way(area.a)[highway]; -
(rel(area.a)[route=road][type=route];>;);
);
(._;>;);out;]]>
</programlisting>
<para>
Az OSM formátum viszont olyan, hogy külön vannak a pontok és az utaknál csak referenciaként kezeli azokat. Szóval itt jön a saját módszerrel való kiszedés. Ezen lehetne javítani, mivel ennél a 6 megás fájlnál is eltartott egy darabig mire lefutott. Főleg az összepárosítgatós rész tartott sokáig. Nagy vonalakban abból áll, hogy kiszedem a hosszúsági és szélességi koordinátákat és magát az id-t amire hivatkoznak majd az utak. Valamint az utaknak az összes referenciáját külön. Itt még ha nagyon akarunk gyorsítani anélkül, hogy ezen változtatnánk előre foglalhatunk le üres helyeket a vektornak, de ez a része a programnak egyáltalán nem vészes teljesítmény terén.
</para>
<programlisting language='c++'>
<![CDATA[
	while (getline(raw, line))
	{
		if (line.find("node id") != std::string::npos)
		{
			points.push_back({ extract(line, "\""), extract(line, "lat=\""), extract(line, "lon=\"") });
		}
		else if (line.find("nd ref") != std::string::npos)
		{
			tempv.push_back(extract(line, "nd ref=\""));
		}
		else if (!(tempv.empty()))
		{
			references.push_back(tempv);
			tempv.clear();
		}
	}]]>
</programlisting>
<para>
Maga a függvény, amivel lekérem a hosszúságot és a szélességet, valamint. Ezt a függvényt lehtne úgy is meghívni, hogy rövidebb illesztést nézzen, de mivel nem volt hosszú a futása, így nem nagyon erőlködtem, hogy külön adjak még a kezdő pozicíóhoz számot, mert így a search.length() - 1 is jó lesz és borzasztó "megerőltető" lett volna az a + valamilyen nagyságú szám.
</para>
<programlisting language='c++'>
<![CDATA[
std::string extract(const std::string& input, const std::string& search)
{
	std::string output;
	std::size_t from = input.find(search) + search.length() - 1;
	while (input[++from] != '"')
	{
		output += input[from];
	}
	return output;
}]]>
</programlisting>
<para>
Ezután már csak össze kellet párostani a referenciákat a megfelelő koordinátákkal, ami elég sokáig tartott és igen valószínű van rá jobb megoldás. Itt igazából jó lett volna tudni, hogy rendezett vagy rendezetlen listáról van szó id szerint. Mivel így egy lineáris kereséssel oldottam meg, amit nyílván bináris kereséssel mondjuk fel lehetett volna oldani. Vagy maga az id beolvasákor kiosztani egy új id-t és pl egy map használatával letárolni a régit és az újat és az alapján megkapni a koordinátákat. De az legjobb az lett volna, ha sorba vannak és nincs is nincs is benne szakadás mert, akkor csak egy konstanst kellet volna kivonni, ahhoz, hogy megkapjam a megfelelő adatokat. Szóval igen nem a legjobb megoldás, lett volna számos jobb, de végülis működött csak időbe került.
</para>
<programlisting language='c++'>
<![CDATA[
	for (unsigned int i = 0; i < references.size(); i++)
	{
		for (unsigned int j = 0; j < references[i].size(); j++)
		{
			getPointIndex(references[i][j], points, lat, lon);
			coordinates << lat << " " << lon << std::endl;
		}
		coordinates << "\n";
	}]]>
</programlisting>
<para>
Itt még üres sorral választottam el az utakat és úgy írtam ki egy fájlba, de később rájöttem, hogy ez felesleges. Mivel amit én akarok az az, hogy egybe át lehessen küldenia GPU-nak és csak tömb egy indexétől számítva adott számú koordináták apalján rajzoljon ki egy vonalat.  És akkor át is térhetünk az opengl részére, hogy hogyan lesz befejezve a program.
</para>
<para>
Itt egy eléggé nem ajánlott megoldást alkalmaztam az adatok "beolvasására". Az első tömb tartalmaza a koordinátákat, míg a második a kezdő indexet és a hosszúságát az útnak. Viszont ahelyett, hogy beolvastam volna a fájlokat hagytam, hogy a preprocesser kisegítsen, mivel lényegében itt nem fog más történni, mint a két txt tartalma bemásolódik az include helyére. És mivel ott {} között vesszővel vannak felsorolva, így valid kód lesz belőle, csak nem egyértelmű és maga a visual studio se szerette annyira. De itt érdemes rendesen fájlból beolvasni mert és akár ez történhet több threaden is és a végén bevárni, hogy mindegyik be legyen olvasva. Valamint érdemes ezeket az adatokat a heap-en tárolni, mivel ezek a fajta adatok elég hamar nagyok tudnak lenni.
</para>
<programlisting language='c++'>
<![CDATA[
	float positions[] =
#include"poPoints.txt"
		;
	unsigned int indexes[] = 
#include"poIndexes.txt"
		;]]>
</programlisting>
<para>
Maga a kiíratás úgy néz ki, hogy átadjuk az összes koordinátát és megmondjuk index alapján, hogy mit szeretnénk a glDrawArrays paraméterei szeint, amik nem mások, mint, hogy mit szeretnénk rajzolni. Vonal, háromszög stb... Hanyas számú indextől kezdődik a rajzolás a megadott tömbben. Valmint, hogy hány elemét figyelje a tömbnek.
</para>
<programlisting language='c++'>
<![CDATA[
		for (int i = 0; i < 32; i++)
			glDrawArrays(GL_LINE_STRIP, indexes[i++], indexes[i]);]]>
</programlisting>
<para>
Ez mind szép és jó, de ha ezt csak így simán futattnánk semmit se látnánk. Mivel alapértelmezetten opengl -1 és 1 között dolgozik. De persze erre is van megoldás glm könyvtár formájában vagy igazából akármilyen megoldás jó, csak kicsit szoroznunk kell.
</para>
<para>
Tehát létrehozunk egy mátrixot, amiben megadjuk, hogy milyen pontokat szerenénk, majd azt a vertex shaderen belűl összeszorozzuk, így a koordináták is a megfelelő helyre fognak kerülni.
</para>
<programlisting language='c++'>
<![CDATA[		glm::mat4 proj = glm::ortho(475308671.0f, 475998139.0f, 216029324.0f, 216602269.0f, -1.0f, 1.0f);
		glm::mat4 mvp = proj;
		glUniformMatrix4fv(glGetUniformLocation(shader, "u_MVP"), 1, GL_FALSE, &mvp[0][0]);]]>
</programlisting>
<para>
Itt a fenti kódrészletben az ortho függvény adja meg, azt, hogy milyen tartományon belűl szeretnénk "látni". Leegyszerűsítve ott adjuk meg az x és y tengely kezdő és végértékeit. Ez úgy néz ki, hogy a vertex shaderben a vertex koordinátája össze lesz szorozva a projection mátrixxal és ezért a koordináták "jó" helyre fognak kerűlni. Ezt úgy érjük el, hogy a már említett projection mátrix bekerűl az mvp-be, aminek most a neve nem releváns. És ennek a mátrixnak a kezdő koordinátáját átadjuk az u_MVP nevű unoformnak, ami össze lesz szorozva vertex koordinátáival. Itt én a minimum és maximum értékeket a projection mátrixnál aszerint választottam, hogy mi volt a legnagyobb és legkisebb érték x és y tengelyre nézve, szóval kisebb torzulások előfordúlhatnak, mivel maga az ablak mérete 720p-s.
</para>
<para>
És ezek után mostmár látnunk kéne az első 16 utat, ami a debreceni régión belűl található az OSM adatbázisában. De helyette egy ilye szépséget kaptam.
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/OSCI3_meh.png" scale="50" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
Ez nem annyira hasolít egy város utcáinak felűlnézeti rajzára. De valószínűleg a kezdő indexekkel lesza a baj az éles váltásokból következtetve. Mivel így egy ponttal később kezz el rajzolni egy ugyanolyan hosszú pontot és az utolsó koordináta már a következő úthoz tartozna. Szóval valahol a kinyert koordinátákat tartalmazó fájl módosításai közben elírtam valamit és rosszúl adtam vissza a kzedő koordinátát. Korigálás után pedig így néz ki.
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/OSCI3_kinda.png" scale="50" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
Ez már elég közel áll ahhoz, amit elterveztem. Nyílván ehhez az kéne, hogy ne a stacken tároljam azt a pár adatot, de szerintem a feladat már ezzel is elkönyvelhető. És mivel érdemes lenne átírni, több fájlba, hogy átláthatóbb legyen ne egy nagy maszlag az egész kód, így az itt tapasztaltak alapján már a következő opengles programhoz ezzel a tudással állok neki.
</para>
<para>
Na még egyszer "előlről" és mostmár tényleg az utakat fogja kirajzolni.
</para>
<para>
Szóval a program írása során többféleképpen oldottam meg magát a drawcallt. A drawcall nem csinál más mint kirajzolja azt, amit mondunk neki. Ez alapvetően egy CPU -> GPU kommunikáció majd a GPU elvégzi a rajzolást és mindenki boldog. Ez attól függően, hogy legacy opengl-t vagy modern opengl-t használunk máshogy néz ki, illetve, hogy modern opengl esetén milyen előkészületeket tettünk különböző módokon tudjuk majd kirajzolni, amit szeretnénk.
</para>
<para>
Maga a rajzolás az OSCI3.cpp-ben a legrosszabb, mivel ott a while ciklusban elég lenne csak a drawcall, ha normálisan előkészítettem volna a dolgokat.
</para>
<para>
Egy jobb megoldás, ha előre létrehozunk egy vertex object array-t vagy VAO rövide. Ez igazából nem más mint azon pontok halmaza, amit ki szeretnénk rajzolni. Viszont ennek a megoldásanak az a hátránya, hogy maga a VAO nem csak koordinátákat tartalmazhat, azzal kapcsolatban, hogy hol helyezkedik el a kirajzolandó dolgunk a világban, hanem tartalmazhat mondjuk textura koordinátákat vagy egyéb információkat, mint példáúl olyan értékek, hogy hogyan is viselkedjen a különböző szögből beeső fénnyel. Ez alapvetően nem gond, de ha arra gondolunk, hogy példáúl, ha egy 3d modelt szeretnénk megjeleníteni és igazából 2d esetén is háromszögekből fogja azt felépíteni. Ebből az következik, hogy ha mondjuk egy négyzetet szeretnénk rajzolni, akkor az két háromszögből lesz megoldva 2d esetén. Ami azt eredményezi, hogy ebben az esetben a 2 pontot úgy mégegyszer meg kell adnunk pluszba. Vagy fogalmazhatnék úgy is, hogy minden háromszög él találkozásakor 2 pontot meg kell adnunk amik ismételve lesznek, teljesen ugyanazokkal az értékekkel és az előbb említett pluszinformációkkal, ha tartalmaz olyat. Ez egy bonyolúltabb 3d model esetén elég hamar elég nagy méreteket fog ölteni feleslegesen.
</para>
<para>
De mit is lehet tenni ez ellen? Először is létre kell hozni egy vertex buffert, ami nem más mint lényegénben egy VAO annyi eltéréssel, hogy minden koordinátapont egyszer szerepel, azaz nem lesz duplikáció és memória terén sokkal jobban kijövünk. Mivel példáúl egy 3d model 3 térbeli koordinátája és és mondjuk 3 textúra koordinátája minden egyes ponthoz nem fog többször megjelenni. Szóval így a helyen spóroltunk, de hogyan fogjuk kirajzolni, mivel mostmár nem lehet sorba menni rajtuk. Itt jön képbe az index buffer, ami a koordinátákból képzet pontoknak az indexe. Ez alatt azt értem, hogy nyílván a valamilyen módon tároljuk az információkat. Nálam ez annyiból állt, hogy ömlesztve x y koordináta párok voltak, mivel csak erre volt szükségem, majd beolvasás után megmondtam az openglnek magának a VAO-nak a layout-ját, hány koordináta az, ami a koordinátákhoz tartozik, normalizált-e, milyen típúsúban van tárolva, és mennyi a koordináták közötti távolság. Mivel a textúrák koordinátájával nem foglalkozi, az a mi feladatunk a shaderben. És ebből ő magának összerakja a pontokat, amiknek megvan annyi koordinátája ahány dimenziós térben dolgozunk. Bár ez 2-től 4-ig terjedhet csak és a pluszinfo, amivel majd mi mondjuk meg máshol a program során, hogy mit kezdjen. Szóval ezeknek a pontoknak az indexeit kell meganunk ha takarékosan szeretnénk kirajzolni a modeleket. Az index során fontos a sorrend, de ez csak egy értékből áll, szóval itt nem gond, ha duplikákódik vagy több lesz belőle. Legalábbis sokkal jobb mint, ha maga a koordinátákból lenne több.
</para>
<para>
Szóval mostmár takarékosan tudunk rajzolni mert az előbb leírt módon elemenet-eket tudunk létrehozni, ahol figyelünk a memóriára is. De mi történik akkor ha több dolgot szeretnénk kirajzolni és nem csak egy modelt? Persze csinálhatjuk azt, hogy több elementet csinálunk és egy for ciklusban mindig egy új drawcall-al kirajzoljuk. De létezik egy olyan csodás fogalom, hogy batch rendering. És ez igazából az aminek hangzik. Külön csökrokban tudunk több dölgot kirajzolni. És mivel c++-t használok ez csak azt jelentheti, hogy érdekel a teljesítmény. Szóval mostmár, a memóriánál megtettük, amit lehetett ideje, hogy a CPU -> GPU kommunikációt is felgyorsítjuk egy kicsit.
</para>
<para>
Ehhez nem kell más mint maaga egy vertex buffer, vagy ahogy az előbb hívtam a pontok. Ez már pipa. Kell még egy index buffer, ami szintén pipa. Ezen kívűl még két tömbre van szükségünk. Egy ami megmondja, hogy az index bufferben honnan kezdve legyen rajzolva. Ez theát a "kezdőpontok" tömbje vagy offset. Valamint kell még egy tömb, ami megadja, hogy hány pontot szeretnénk kirajzolni majd. tehát egyszerűen egy tömbben megvan hanyadik indextől kezdve hány indexet szeretnénk rajzolni és az indexnek megfelelő vertex kerűl kirajzolásra és mindezt úgy, hogy egy drawcallal több modelt is ki tudjuk rajzolni.
</para>
<programlisting language='c++'>
<![CDATA[glMultiDrawElements(GL_LINE_STRIP, countArray, GL_UNSIGNED_INT, (const void**)offset, 8854);]]>
</programlisting>
<para>
És igen az a fenti egy sorral megoldjuk, hogy 8854 különálló vonalat tudja ki rajzolni, ami nem más mint Debrecen összes fajta útjának összege. Legalábbis, ami az OSM szerint létezik. Ebből adódik, hogy mostmár a heapen vannak tárolva az adatok és nem fog szólni 1kb után, hogy helló szia elfogyott a stack.
</para>
<para>
De nézzük a program többi részét is mert, több helyen is változtak a dolgok. Az elején lévő előkészítjük a környezetet kihagynám és csak a lényegre koncetrálnék.
</para>
<para>
Szóval mivel 4 tömbre van szükdésgünk miért ne tárolnánk külön fájlban őket és így párhuzamosítanni lehet a beolvasást.
</para>
<programlisting language='c++'>
<![CDATA[	float* vertexArray = new float[119072];
	std::thread rVertex(readData<float>,"src/point.txt", vertexArray, "float");
	
	unsigned int* indexArray = new unsigned int[119072];
	std::thread rIndex(readData<unsigned int>, "src/index.txt", indexArray, "unsigned");
	
	GLsizei* countArray = new GLsizei[8854];
	std::thread rCount(readData<int>, "src/count.txt", countArray, "int");
	
	char** offset = new char*[8854];
	std::thread rOffset(readOffset, "src/offset.txt", offset);]]>
</programlisting>
<para>
Itt igazából van egy kis hiba, illetve kettő. Egy az, hogy jelenleg manuálisan van megadva, hogy mennyi szeretnék allocálni. Kettő pedig, hogy az indexArray-nak igazából csak az első felét használom, mivel 119072 sor volt az x y koordináták száma, hogy még nem lett VAO. Tehát igazából csak az első 59536 index van haszálva.
</para>
<para>
Ez után a threadeket bevárjuk, aminek a sorrendjén lehetne változtanti, mivel a rVertex thread olvasa a legtöbb adatot jelen esetben így az kerülhetne legutoljára.
</para>
<programlisting language='c++'>
<![CDATA[
	rVertex.join();
	rIndex.join();
	rCount.join();
	rOffset.join();]]>
</programlisting>
<para>
Ez után létrehozuk a vertex buffert, ami a constructorban rögtön bindolásra is kerűl, tahát egyből lehet használni. Valamint magát az adatunk kiosztását is megadjuk, amit az elején leírtam.
</para>
<programlisting language='c++'>
<![CDATA[vertexBuffer vb(vertexArray, 119072 * 2 * sizeof(float));


vertexBuffer::vertexBuffer(const void* data, unsigned int size)
{
	glGenBuffers(1, &id);
	glBindBuffer(GL_ARRAY_BUFFER, id);
	glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);
}

	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), 0);}]]>
</programlisting>
<para>
Ezután a mondhatni ugyanezt megcsináljuk még az index bufferrel is, csak ott a glBindBuffer és glBufferData hajszálnyit van máshogy paraméterezve, illteve az index buffernek nem kell megadni a layout-ját.
</para>
<para>
Ezután pedig kérünk egy shadert is, ami nem kötelező olyan szempontból, hogy ha nem hozunk mi létre egyet, talán megszán minket a grafikus driver, ha ott úgy van implementálva, hogy ha nincs, akkor adjon egy alap shadert. De akkor nem tudnánk mozgatni a képet illetve a színeket se tudnánk uniformon keresztűl variálni.
</para>
<para>
A shader két részből áll. Vertex és fragment shader. Az előbbi a geometria alakzat pontjaival kapcsolatos, míg az utóbbi majd a pontokkal közrezárt pixeleket tölti ki megfelelően. Maga az opengl szereti ezeket külön kezelni, ami ahhoz vezet, hogy két külön fájlban tároljuk. De ha megtudjuk különböztetni a vertex és fragment shadert, akkor igazából egy fájlba is rakhatjuk.
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/shader.png" scale="200" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<programlisting language='c++'>
<![CDATA[S_BEGIN VERTEX
#version 330 core

layout(location = 0) in vec4 position;

uniform mat4 u_MVP;

void main()
{
	gl_Position = u_MVP * position;
};

S_BEGIN FRAGMENT
#version 330 core

layout(location = 0) out vec4 color;

uniform vec4 u_Color;

void main()
{
	color = u_Color;
};]]>
</programlisting>
<para>
Ezek mondhatni kis programok, amiket majd a GPU hajt végre. És ha nincs shaderünk akkor igazából nem is fogunk semmit se látni abból, amit eddig ki akartunk rajzolni. A uniformokról annyit, hogy azokon keresztűl később tudjuk majd manipulálni a geometriai alakzatot. Jelen esetben a helyét tudjuk változtatni panning esetén, illetve a színét az utkat reprezentáló vonalaknak.
</para>

<para>
Maga a shader beolvasáskor az S_BEGIN VERTEX/FRAGMENT során lesz eldöntve, hogy most hova tartozik és a függvényhívás során külön adja vissza csak a vertex és fragment shadert, úgy ahogy az opengl elvárja. Majd ezután lefordítjuk és futattjuk azt.
</para>
<programlisting language='c++'>
<![CDATA[
shader::shader(const std::string& filepath)
	:id(0)
{
	readShader(filepath, vertexShader, fragmentShader);
	id = createShader(vertexShader, fragmentShader);
}

unsigned int shader::createShader(const std::string& vertexShader, const std::string& fragmentShader)
{
	unsigned int program = glCreateProgram();
	unsigned int vs = compileShader(GL_VERTEX_SHADER, vertexShader);
	unsigned int fs = compileShader(GL_FRAGMENT_SHADER, fragmentShader);

	glAttachShader(program, vs);
	glAttachShader(program, fs);
	glLinkProgram(program);
	glValidateProgram(program);
	glDeleteShader(vs);
	glDeleteShader(fs);

		return program;
}

unsigned int shader::compileShader(unsigned int type, const std::string& source)
{
	unsigned int id = glCreateShader(type);
	const char* src = &source[0];
	glShaderSource(id, 1, &src, nullptr);
	glCompileShader(id);

	int result;
	glGetShaderiv(id, GL_COMPILE_STATUS, &result);
	if (result == GL_FALSE)
	{
		int length;
		glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length);
		char* message = (char*)alloca(length * sizeof(char));
		glGetShaderInfoLog(id, length, &length, message);
		std::cout << "error" << (type == GL_VERTEX_SHADER ? " vertex" : " fragment") << std::endl;
		std::cout << message << std::endl;
		glDeleteShader(id);
		return 0;
	}

	return id;
}]]>
</programlisting>
<para>
Maga a uniformokon keresztűl való manipulálás úgy néz ki, hogy megkérdezük, hogy az adott nevű uniform hol található. Amire az opengl visszaadja a helyét és updatelhetjük a uniform értékeit. Ezen annyit lehetne javítani, hogy cache-be rakjuk a már lekért uniformok helyét. Mondjuk egy map segítségével, de jelenleg csak kettő van, szóval ezt elhagytam.
</para>
<programlisting language='c++'>
<![CDATA[void shader::setUniform(const std::string& name, float v0, float v1, float v2, float v3)
{
	glUniform4f(getUniformLocation(name), v0, v1, v2, v3);
}

int shader::getUniformLocation(const std::string& name)
{
	int location = glGetUniformLocation(id, name.c_str());
	return location;
}]]>
</programlisting>
<para>
És ezután már csak a drawcall hiányzik és már mindenki boldog is.
</para>
<programlisting language='c++'>
<![CDATA[glMultiDrawElements(GL_LINE_STRIP, countArray, GL_UNSIGNED_INT, (const void**)offset, 8854);]]>
</programlisting>
<para>
Ezután pedig egy ilyen gyönörűség fogad minket, ami szerintem eléggé hasonlít egy bizonyos városhoz.
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/19_5_1.png" scale="60" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
És ahogy látható a képen azt a közel 10000 különböző hösszúságú vonalat 60 fps-el tudja rajzolgatni. Debugger módban, ami nem tartalmaz a compiler álltal megadható optimalizációkat. Sőt ellenkezőleg még plusz dolog is a debugging segítéséhez kerűl be. Úgy hogy ez integrált videókkártyát használt egy laptopon és mellesleg a visual studio-n belűl lett futatva, ami még monitoroz is. Ja és még van mellete 4x mintavételezés is, csak, hogy szebb éleket kapjunk. És így tartotta sziklaszilárdan a 60 fps-t. Ami lehetne több is, de igazából az fps a monitor refresh rate-jehez lett állítva.
</para>
<programlisting language='c++'>
<![CDATA[glfwSwapInterval(1);]]>
</programlisting>
<para>
Maga a többszöri mintavételezést meg lehet oldani shaderen belűl is. De én most a könyebb megoldást választottam és rábíztam magára a grafikus driveremre, hogy meg tud-e szánni egy előre létrehozttal-e. Szóval ez nem feltétlen fog működni így minden eszközön.
</para>
<programlisting language='c++'>
<![CDATA[glfwWindowHint(GLFW_SAMPLES, 4);
glEnable(GL_MULTISAMPLE);]]>
</programlisting>
<para>
Magának a WindowHint-nek az előtt kell lennie, hogy létrehozzuk az ablakot. A glEnable-el pedig be lehet kapcsolni, hogy igen szeretnénk több mintát. És nyílván a glDisable paranccsal pedig ki lehet kapcsolni. Maga a többszöri mintevételezés pedig csak annyit jelent, hogy egy pixelnek nem csak a közepét nézzük, hanem több pontját.
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/aa1.png" scale="60" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/aa2.png" scale="60" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/aa3.png" scale="60" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/aa4.png" scale="60" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
És ha már a debugger módot említettem van nekem egy ilyenem is.
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/19_5_2.png" scale="65" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
Ezek az üzenetek csak akkor jelennek meg, ha debugger módban fordítom a programot anélkül, hogy bármi mást változtatnék, mivel a visual studio prepocessorának meg lett mondva hogy csak debugger mód esetén definiálja a DEBUG_M-et.
</para>
<programlisting language='c++'>
<![CDATA[#ifdef DEBUG_M
#define LOG(x) std::cout << "DEBUG | "  << x << std::endl;
#else
#define LOG(X)
#endif]]>
</programlisting>
<para>
Így pedig az alábbi kódot nem kell kivenni a kódból mivel a prepocessor majd kiszedi alapból, ha nincs definiálva a DEBUG_M. Tehát amikor majd kell ez nem fogja befolyásolni a teljesítményt.
</para>
<programlisting language='c++'>
<![CDATA[LOG("Cursor Pressed at " << previous_x  << " : " << previous_y);]]>
</programlisting>
<para>
Amit még érdemes megjegyezni, az az, hogy a jelenleg kirajzolt kép kicsit torz. Ez azért van mert maga az ablak az egy 16:9-es arányt használ.
</para>
<programlisting language='c++'>
<![CDATA[window = glfwCreateWindow(1280, 720, "...", NULL, NULL);]]>
</programlisting>
<para>
Az opengl viszont nem ebben az arányban rajzol. Ezt más értékek megadásával viszont könnyen lehet orvosolni.
</para>
<programlisting language='c++'>
<![CDATA[glm::mat4 proj = glm::ortho(474198409.0f, 476454687.0f, 213569142.0f, 218833644.0f, -1.0f, 1.0f);]]>
</programlisting>
<para>
A program imgui-t használ GUI megjelenítőként, ahol lehet vonalvastagságot, vonalszínt, "háttérszínt" állítani. Illetve visszajelzést ad, hogy éppen le van-e nyomva a bal egérgomb és fps-t számol pluszba.
</para>
<programlisting language='c++'>
<![CDATA[		ImGui::Checkbox("lbutton_down", &lbutton_down);
		ImGui::SliderInt("line width", &width, 1, 10);
		ImGui::ColorEdit3("clear color", (float*)&clear_color);
		ImGui::ColorEdit3("line color", (float*)&line_color);
ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);]]>
</programlisting>
<para>
Jelenleg a kamera mozgatás kicsit lassú, mert screenspacebeli értékek alapján mozgat és a screenspace és worldspace aránya most nem 1:1. Ezt érdmees lenne wordspcare konvertálni a tökéletes élmény miatt vagy legalább még beszorozni egy kicsit.
</para>
<programlisting language='c++'>
<![CDATA[static void cursor_position_callback(GLFWwindow* window, double xpos, double ypos)
{
	if (lbutton_down)
	{
		LOG("X moved: " << (previous_x - xpos) << " Y moved: " << (previous_y - ypos));
		offsetX = previous_x - xpos;
		offsetY = previous_y - ypos;
		translation.x -= offsetX;
		translation.y += offsetY;
		previous_x = xpos;
		previous_y = ypos;
	}
}

static void mouse_button_callback(GLFWwindow* window, int button, int action, int mods)
{
	if (button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS)
	{
		glfwGetCursorPos(window, &previous_x, &previous_y);
		lbutton_down = true;
		LOG("Cursor Pressed at " << previous_x  << " : " << previous_y);
	}
	if (button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_RELEASE)
	{
		lbutton_down = false;
		glfwGetCursorPos(window, &x, &y);
		LOG("Cursor Released at " << x << " : " << y);
	}
}]]>
</programlisting>
<para>
Zoomolási funkció is van, de ott meggyűlt a bajom az orthograpic kamerával, így inkább kikommenteltem, mert hiába működött majdnem jól én mégsem voltam megelégedve vele.
</para>
<para>
Nagyjából ennyit tud a program, de ezen már könnyen lehet dolgozni. Jelenleg a batch rendererrel eléggé hasonlít ahhoz, ahogy a game enginek material szerint egybe kitolják a geometriai alakokat magukból. És ehhez már könnyű pluszt hozzáadni. Példáúl ha azt szeretném, hogy ne csak az utakat jelenítse meg hanem a házak körvonalát is. Akkor csak annyit kell tennem, hogy magát a VAO-t frissítem, a házak pontjait is tartalmazza adott az utak index buffere és a másik két tömb. Ezután létrehozok egy másik index buffert ami a házakat tartalmaza és hasonlóan a másik két tömböt. majd egy másik alőször kirejzolom az utakat bindolom a házak indexe bufferét majd a drawcallba megadom a neki megfelelő tömböt. És akár már szinet is állíthatok neki még előtte.
</para>
<para>
Szóval igen elég pofás lett így a végére és még annyi lemarad, hogy magát a koordinátákat ugye saját magam írt program segítségével szedem ki az xml-ből, ami lehetne gyorsítani, mert jelenleg az a program fájó pontja. És akár a két programot össze is lehetne vonni, hogy ne kelljen külön másik programot használni csak ahhoz, hogy meglegyen egy olyan adatunk, amit már tud használni.
</para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
</chapter>                
