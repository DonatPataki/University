<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Lauda!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Port scan</title>

        <para>
            Megoldás forrása: <link xlink:href="https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/scan.java">https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/scan.java</link>               
        </para>
<para>
A megadott program nem csinál mást mint visszaad egy listát a 0-tól 1024-ig tartó TCP kapukról, hogy az adott időben melyik volt használva és melyik nem. Ennek a megvalósítására kivételkezelést használ és ez lenne a lényeg, hogy miért ezt használja. De először nézzük a programot röviden.
</para>
<programlisting language='java'>
<![CDATA[        for(int i=0; i<1024; ++i)
            
            try {
                
                java.net.Socket socket = new java.net.Socket(args[0], i);
                
                System.out.println(i + " figyeli");
                
                socket.close();
                
            } catch (Exception e) {
                
                System.out.println(i + " nem figyeli");]]>
</programlisting>
<para>
A fenti programrész igazából az egész main function és igazán egyszerű megvalósítás. Az hogy 0-tól 1024-ig nézzük a kapukat az egyértemű, hogy egy for cikluson belűl lesz megoldva. Viszont egy try catch blokkban található maga a socket létrehozása és azt látjuk, ha létre tudja hozni, akkor használatban van, ha pedig akármilyen hiba exception jön akkor nem figyelnek.
</para>
<para>
Ha tudni akarjuk, hogy pontosan miért fog mőködni ez a megoldás akkor egy gyors kereséssel meg is lehet találni az oracle oldalán, hogy a függvény mikor dobhat kivételt és egy rövid leírást is.
</para>
<programlisting language='java'>
<![CDATA[public Socket(String host, int port)]]>
</programlisting>
<para>
Röviden fogalmazva IOException-t fog dobni ha nem tud létrehozni egy socketet. Vagy másképpen fogalmazva, ha nincs nyitva port, akkor nem fogja tudni létrehozni a socketet és egy exceptionnel lep meg inkább minket. Ami rögtön meg is magyaráza, hogy miért try catch blokkban van az egész. De ezen kívűl az is kiderűl, hogy ha a host nevét null-ként adjuk át akkor a loopback címmel fog alapértelmezetten dolgozni. És ezzel a módszerrel el is kezdhetünk nyitott portok után keresni akár biztonsági okokból akár nem.
</para>
    </section>        
              
    <section>
        <title>AOP</title>

        <para>
            Megoldás forrása: <link xlink:href="https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/aop.aj">https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/aop.aj</link>               
        </para>
<para>
Aspect oriented programming nem más mint egy olyan programozási módszer, ami a modularitásra épül és ennek segítségével anélkül lehet új viselkedést hozzáadni a már meglévő kódokhoz, hogy azokat módosítanánk. Ezt pointcutok és joint pointok segítségével éri el. Lényegében amire ezt lehet használni az főként debuging célok. Mivel példáúl jól lehet vele logolni, hogy egy függvény mondjuk hányszor lett megírva. De az is igaz, hogy új viselkedést is hozzá lehet adni mint példáúl ennél a feladatnál.
</para>
<para>
A bináris fákat három féleképpen lehet bejárni. Inorder, postorder és preorder sorrendben. Ezek az elnevezések arra utalnak, hogy milyen sorrendben vannak feldoldolgozva a gyökér elemek a gyerekekhez képest. És mivel ez egy rekurzív függvényhívás lesz, vagyis kettő így elég egyszerű megvalósítani is.
</para>
<para>
Először megadjuk, hogy hol szeretnénk egy pointcutot létrehozni. Lényegében ezzel adjuk meg, hogy hol szeretnénk beleszólni a program működésébe.
</para>
<programlisting language='java'>
<![CDATA[	public pointcut travel(LZWBinaryTree.Node n, PrintWriter os) 
	: call(public void LZWBinaryTree.printTree(LZWBinaryTree.Node, PrintWriter)) && args(n,os);]]>
</programlisting>
<para>
Ezután megadjuk, hogy mit szeretnénk csinálni. Mi most a poncut után. Azaz akkor amikor már lefutott a függvény az alábbi kis kódrészletet szeretnénk lefutatni, ami nem tesz mást mint elkezdi a rekurziót az inorder és postorder bejárásokhoz és kiírja a tartalmukat egy fájlba.
</para>
<programlisting language='java'>
<![CDATA[    after(LZWBinaryTree.Node n, PrintWriter os) throws FileNotFoundException : travel(n, os)
    {
    	inOrder(n,new PrintWriter("in-order.txt"));
    	depth = 0;
    	postOrder(n,new PrintWriter("post-order.txt"));
    }]]>
</programlisting>
<para>
És végül itt a két függvény. Ezekben nincs semmi különös. Mivel rekúrzívak így egyszer csak be kell indítani őket és onnantól kezdve végigmennek a fán.
</para>
<programlisting language='java'>
<![CDATA[
    public void inOrder(LZWBinaryTree.Node n, PrintWriter p)
    {
    	if (n != null)
        {
            ++depth;
            for (int i = 0; i < depth; ++i)
                p.print("---");
            p.print(n.getValue () + "(" + depth + ")\n");
            inOrder (n.getLeftChild (), p);
            inOrder (n.getRightChild (), p);
            --depth;
        }
    }
    public void postOrder(LZWBinaryTree.Node n, PrintWriter p)
    {
    	if (n != null)
        {
            ++depth;
            postOrder (n.getLeftChild (), p);
            postOrder (n.getRightChild (), p);
            for (int i = 0; i < depth; ++i)
                p.print("---");
            p.print(n.getValue () + "(" + depth + ")\n");
            --depth;
        }
    }]]>
</programlisting>
    </section>

    <section>
        <title>Junit teszt</title>

        <para>
            Megoldás forrása: <link xlink:href="https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/LZWBinFaTest.java">https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/LZWBinFaTest.java</link>               
        </para>
<para>
A programozóknak szükségük van eszközökre amikkel könnyebbé lehet tenni a debugging folyamatot vagy magát azt, hogy egy programot, hogyan tudnak tesztelni. Ezek még egy kisebb programnál nem okoznak gondot, de mikor már nagyobb projektről van szó, akkor már elég bonyolulttá tud válni a dolog. Ezt a tesztelési fázist szeretné megkönnyíteni a junit. Ennek segítségével olyan programokat tudunk írni java nyelven, amivel tesztelni tudjuk java osztályainkat és ha nem is tudjuk rögtön, hogy hol a hiba legalább arra választ kaphatunk, hogy mondjuk melyik osztályban vagy függvényben kell keresni.
</para>
<para>
Junit kicsit olyan mint a AOP egy kicsit átgondolása mivel ugyanúgy lehetőség van tesztelésre anélkül, hogy a forráskódot módosítanánk. Példáúl lehetőség van tageket megadni, amikkel lehet szűrni a @Tag megadásával. Vagy olyan függvényt írni, ami lefog futni még maga teszt előtt vagy a teszt után @BeforeAll és @AfterAll formájában, így példáúl a teszt előtt bekérhetjük az adatokat és a végén mondjuk összegezetjük, hogy mi lett az eredménye. Vagy akár minden teszt medódus előtt vagy után is csinálhatunk ilyet, ha logolni szeretnénk példáúl valamit. De akár egy teszt medusnak vagy osztálynak meg is modhatjuk, hogy most őt nem szeretnénk lefutattni. És még lehetne sorlni, hogy miket lehet vele csinálni, de inkább nézzük magát a feladatot.
</para>
<para>
Szóval ha megírtunk egy osztáyt, akkor igazából el kell kezdenünk goldolkozni, hogy milyen bemenetre milyen végeredmény várható és ezt kell összehasonlítani azzal, hogy valójában mit kapunk. Erre önmagában nem szükséges a junit, de ha használjuk, akkor nem fogjuk összeszemetetlni a saját kódunkat. Tehát binfa esetén megnézzük, hogy egy bemenetre milyen fát kéne kapunk és milyen értékeinek kéne lennie.
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/lzwpapir.jpeg" scale="70" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
Most hogy megvan, hogy egy adott bemenetre milyen értékeket kéne adni elkezdhetjük megírni magát a teszt programot. De még előtte fontos megjegyezni, hogy érdemes olyan bemenetet választani, ami problémás lehet vagy érdemes tesztelni. Nyílván itt a binfánál nincs olyan nagy választék, de nagyobb projekteknél elképzelhető, hogy több különböző bemenetet is tesztelni kell.
</para>
<programlisting language='java'>
<![CDATA[public class LZWBinFaTest {
    LZWBinFa binfa = new LZWBinFa();
    
    @Test
    public void testHozzarendel() {
        char[] minta = "01111001001001000111".toCharArray();
        
        for(char betu: minta ){
            binfa.hozzarendel(betu);
        }
        
        assertEquals(4, binfa.getMelyseg());
        assertEquals(2.75, binfa.getAtlag(), 0.01);
        assertEquals(0.957427, binfa.getSzoras(), 0.000001);
    }    
    
}]]>
</programlisting>
<para>
A fenti program pedig teszteli a bemenetet olyan módon, hogy létrehozunk egy elemét a binfa osztálynak. Azután belerakjuk a már papíron felhasznált bemenetet és megnézzük, hogy maga az értékek, amiket kapnunk kell azok mennyire egyeznek meg azzal, amit kapnunk kéne. Érdemes megjegyezni, hogy milve az átlag és a szórás azok nem egész típusok ezért kerekítés miatt lehet nem pont ugynazt az eredményt kapjuk, mivel véges a memória. Példáúl 1 / 3 * 3 nem lesz egyenlő eggyel ugyanezen ok miatt és ezért adtunk meg egy kis toleranciát ha elófordúlna ilyesmi.
</para>
    </section>

    <section>
        <title>OSCI</title>

        <para>
            Megoldás forrása: <link xlink:href="https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/OSCI.cpp">https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/OSCI.cpp</link>               
        </para>
<para>
Leírás szerint maga a program annyi, hogy egy egyszrű opengl-es megjelenítő és egy kocsit lehet rajta irányítani. Viszont ez az opengl-es megjelenítés annyira nem volt kötelező legalábbis azokból, amit én hallotam és meg lehetet oldani unityben is. Viszont ha unityben csináltam volna akkor már régen kész lennék vele és nem lenne kihívás. Szóval én szeretem ha fáj és ezért én a leírásból indultam ki és a terv az, hogy egy 2d kocsit lehessen irányítani.
</para>
<para>
Még maga a feladat leírása előtt szeretném kifejezni, hogy mennyire hálás vagyok azért, hogy hogyan is működik az opengl. Szóval maga a grafikus driver implementlja a dolgokat és nyílván különboző gyártók között lesz eltérés. Már csak azért is mert maga az opengl nem köti ki mindennek, hogy hogyan is kéne pontosan működnie. Példáúl adott a lenti hiba. Amit csak akkor kap meg az ember, ha külön visszakéri a hibákat. De a lényeg, hogy van ott egy szép hosszú sor, ami vonza az ember tekintetét és úgy voltam vele, hogy hát megnézem mi lenne rá a megoldás. Amire megkaptam, hogy a vertex és fragment shadert felcseréltem. Amit hosszas nézegetés után sem értettem mert nem. Majd később egy másik eszköznél ugyanaz a program a hiba első sorát adta vissza, amiből egyértelmű, hogy csak pancser vagyok és elírtam egy változót. 
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/osci.png" scale="80" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
Így egy rövid bevezető után végre elkezdhetünk beszélni magáról a programról.
</para>
<para>
Szóval maga opengl segítségével kéne megjeleníteni pár objectet és jobb esetben még interaktálni is lehet velük. Én ehhez a feladathoz <link xlink:href="https://www.glfw.org/">GLFW</link> könyvtárat használtam, ami nem más mint ad egy crossplatform supportot az opengl-hez. Tehát ha nem csak windowson szeretném hogy fusson, akkor csak az adott platformra kell lefordítani. Érdemes még azt is megjegyzeni, hogy windows esetében opengl1.1 az utolsó kiadott verzió, ami kicsit régi. Valamint azt érdemes megjegyezni, hogy opengl használata során mi nem látjuk magát a forráskódokat csak függvényeket használunk és maga az utasítássorozat a grafikus kártya driverében van implementálva. Ezért igazából ha újabb verziót szeretnénk használni windowson mint opengl1.1 ezért szükségünk lesz még egy opengl extension libraryre, ahonnan megkapjuk a függvényeket. Ehhez én <link xlink:href="http://glew.sourceforge.net/">GLEW</link>-t használtam, ami szintén cross-platform.
</para>
<para>
Szóval le vannak tudva a függvénykönyvtárak és mostmár elkezdhetjük magát a programot írni. Kiindulási alapnak GLFW oldalán meg lehet találni egy kódot ami készít egy adott felbontású ablakot.
</para>
<programlisting language='c++'>
<![CDATA[#include <GLFW/glfw3.h>

int main(void)
{
    GLFWwindow* window;

    /* Initialize the library */
    if (!glfwInit())
        return -1;

    /* Create a windowed mode window and its OpenGL context */
    window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    /* Make the window's context current */
    glfwMakeContextCurrent(window);

    /* Loop until the user closes the window */
    while (!glfwWindowShouldClose(window))
    {
        /* Render here */
        glClear(GL_COLOR_BUFFER_BIT);

        /* Swap front and back buffers */
        glfwSwapBuffers(window);

        /* Poll for and process events */
        glfwPollEvents();
    }

    glfwTerminate();
    return 0;
}]]>
</programlisting>
<para>
Itt nyíván meg kell adni include directorinak azt, ahova pakoltuk a GLFW és a nekünk megfelelő visual studio verzióval rendeklehóző mappát a linkernek. Valamint dependeciesnél magát az opengl32.lib-et és eldöntjük, hogy hogyan szeretnénk linkelni a GLFW-t, mivel nincs miért ne statikusan linkelni, így megadhatjuk a megfelelő .lib fájlt.
</para>
<para>
Ezek után már tudunk is használni legacy opengl kódokat. Amik így visszagondolva elég egyszerűek. Példáúl egy háromszög rajzolása.
</para>
<programlisting language='c++'>
<![CDATA[        glBegin(GL_TRIANGLES);
        glVertex2f(0, 0);
        glVertex2f(1, 0);
        glVertex2f(0, 1);
        glEnd();
]]>
</programlisting>
<para>
Modern opengl-ben ez kicsit bonyolúltabban néz ki. És mivel szeretem ha fáj ezért miért is ne próbálkoznék azzal. Szóval ehhez előbb includolni kell GLEW-t és máris tudunk modern opengl függvényeket használni. Ha statikusan szeretnénk linkelni, akkor viszont definiálnunk kell GLEW_STATIC-ot. Includolásnál fontos, hogy még GLFW előtt includoljuk valamint akkor kell inicializálni mikor már van egy valid opengl context. 
</para>
<para>
Maga drawcall csak ennyi, ami egy kicsit megtévesztő mivel kell neki egy kis előkészítés.
</para>
<programlisting language='c++'>
<![CDATA[glDrawArrays(GL_TRIANGLES, 0, 3);]]>
</programlisting>
<para>
Modern opengl esetében két féleképpen lehet előkészíteni a dolgokat. Előszor egy VAO kell és ha szerenénk, akkor már elementeket rajzolunk. Index buffereknek annyi szerepe van, hogy ne ismételjünk vertexet feleslegesen a memóriában, hanem adjuk meg magukt a pontokat és egy indexeket tartalmazó tömbben megtalálhtó, hogy hogyan rajzolja ki háromszögekből az adott objektumot.
</para>
<programlisting language='c++'>
<![CDATA[
	unsigned int buffer;
	glGenBuffers(1, &buffer);
	glBindBuffer(GL_ARRAY_BUFFER, buffer);
	glBufferData(GL_ARRAY_BUFFER, 6 * sizeof(float), positions, GL_STATIC_DRAW);

	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), 0);]]>
</programlisting>
<para>
Szóval ha a fenti kódot beírtuk akkor még lehetséges, hogy csak egy fekete képet látunk, mivel nincs shaderünk és ezt a driverünk dönti el, hogy szeretne nekünk adni egy alap shadert vagy nem ad és csak egy fekete képet látunk. A fenti kód egyszerűen nem csinál mást mint, létrehoz egy buffert, ami positions tömb elemeit tartalmaza. Csak azért néz ki, így mivel meg is adjuk, hogy milyen bufferről van szó, mekkora a mérete, miből és statikusat szeretnénk-e vagy dinamikusat példáúl. Ezen kívűl előfordúlhat, hogy nem csak a vertex pozicíóit tároljuk a VAO-ban ezért azt is meg kell adni, hogy hogyan épül fel a vertexattribpointer segítségével. Ez olyanokat tartalmaz, mint hgoy milyen a típusa, normalizált-e hány vertex tartozik egy pontot, mennyi a pontok leírása közötti távolság. Ezután pedig a VRAM-ban lesz tárolva az adatunk.
</para>
<para>
Ez mind jó egy háromszög esetében, de bonyolúltabb alakzatok is háromszögekből lesznek felépítve és szeretnénk elkerűlni a pontok duplikálását. Erre pedig egy index buffert kell létrehozni, ahol megadjuk, hogy melyik indexű vertex következik.
</para>
<programlisting language='c++'>
<![CDATA[	unsigned int ibo;
	glGenBuffers(1, &ibo);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6  * sizeof(unsigned int), indices, GL_STATIC_DRAW);]]>
</programlisting>
<para>
Ezután már a gldrawelemnts-el szertnénk kirajzolni, mivel az index bufferrel dolgozik.
</para>
<programlisting language='c++'>
<![CDATA[glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);]]>
</programlisting>
<para>
Ezek után érdemes shadert írni. Már csak azért mert nincs megszabva, hogy ha nincs akkor kapunk egy alap shadert, ami azt következi, hogy nem fogunk semmit se látni abból, amit ki szeretnénk írni. Valamint ha a négyzetre rárakunk egy textúrát, ahhoz megint szükségünk van shaderre. 2 féle shader létezik vertex és fragment shader. Az előbbi a vertex pontoknál ényeges, míg az utóbbi a kitöltendő pixeleknél.
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/shader.png" scale="150" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
Maga a kocsi mozgása, billentyű letésre törtne, amihez csak le kell kérni az adott billentyű leütéseket és megnézni, mely gomb került leütésre. Viszont ezen még lenne mit javítani.
</para>
<programlisting language='c++'>
<![CDATA[static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
	if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
		glfwSetWindowShouldClose(window, GLFW_TRUE);
	if (key == GLFW_KEY_W)
	{
		std::cout << "w\n";
		translation.x += sin(angle) * 0.01f;
		translation.y += cos(angle) * 0.01f;
	}

	if (key == GLFW_KEY_S )
	{
		std::cout << "s\n";
		translation.x -= sin(angle) * 0.01f;
		translation.y -= cos(angle) * 0.01f;
	}

	if (key == GLFW_KEY_D)
	{
		std::cout << "d\n";
		angle -= 5.0f;
	}

	if (key == GLFW_KEY_A)
	{
		std::cout << "a\n";
		angle += 5.0f;
	}
}]]>
</programlisting>
    </section>

    <section>
        <title>OSCI3</title>

        <para>
            Megoldás forrása: <link xlink:href="https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/OSCI3.cpp">https://github.com/DonatPataki/University/blob/master/prog2/bhax/thematic_tutorials/bhax_textbook/src/lauda/OSCI3.cpp</link>               
        </para>
<para>
Maga a feladat leírása azt mondta, hogy rajzoljuk ki opengl-ben Debrecen utcáit. Vagyis pontosabban csak utakat jelenítsen meg és nekem valahogy ez csapódott hozzá alapból és ezt kezdtem el csinlálni.
</para>
<para>
Még maga a feladat leírása előtt annyit, megjegyeznék, hogy maga a program működik, de annyi limitációval rendelkezik, hogy magát az utcák pontjainak koordinátái és az indexek és, hogy mennyit rajzoljon az a stacken tárolódik. Ez alapvetően nem olyan nagy baj, de egy ilyen programnál, elég hamar túl lehet lépni azt a memóriahatárt, amit a stacken lehet tárolni. Ezért itt csak az első 16 út van kirajzolva, olyan sorrendben, ahogy az osm tárolta. De lényegében ez csak egy tanuló program, hogy hogyan is jutottam el addig, hogy kirajzolja.
</para>
<para>
Szóval maga az alapelképzelés az volt, hogy Debrecen térképét meg lehet kapni xml formában OSM oldaláról és én onnan saját programot írva kiszedem a nekem hasznos információkat példáúl az utcák koordinátáit és már csak ki kell rajzolni opengl-ben. És ilyenkor jönnek azok a finomságok, hogy az OSM oldaláról nem lehet letölteni mert node limit van. Ekkor nem estem kétségbe és megnéztem hol van tükrözve az adat, hogy le tudjam majd onnan tölteni. Így kerültem a geofabrik oldalára, ahol le kicsit túl lőttem a célon és letöltöttem egész Magyarországra vonatkozó adatokat. Ami kicsomagolás után 3 gigát nyomott...  És volt vele egy kicsi gond...
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/size.png" scale="100" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
Szóval hogy elérte a 2 GB-s limitet és ezért nem lehet ilyen módon megnyitni. De én nem esetem kétségbe, mivel nem az a fajta ember vagyok és letöltöttem egy olyan programot, ami tud nagyobb fájlokat is kezelni és láttam 54534701 szép sort, amiből elég sokmindent ki tudtam szedni hasszas nézegetés után, de azért mégiscsak kicsit túlzás, hogy ezzel dolgozzak.
</para>
<para>
Ekkor már mondhatni, kicsit visszaesett bátorsággal kezdtem el keresgélni, hogy hogyan is lehetne leszűrni az OSM adatait. És mint egy isteni sugallat hatására találtam meg az <link xlink:href="https://overpass-turbo.eu/">overpass turbo</link> nevezetű oldalt, ami OSM adatokkal dolgozik és lehet szűrni querry segítségével. Továbbá a visszaadot xml-t le lehet tölteni. Ahol örömben az alőbbi querryvel ki is szedtem a az utakat. És így már csak egy kis csinos 6 megás fájllal kell dolgozni.
</para>
<programlisting>
<![CDATA[area[name="Debrecen"][type=boundary]->.a;
(
way(area.a)[highway]; -
(rel(area.a)[route=road][type=route];>;);
);
(._;>;);out;]]>
</programlisting>
<para>
Az OSM formátum viszont olyan, hogy külön vannak a pontok és az utaknál csak referenciaként kezeli azokat. Szóval itt jön a saját módszerrel való kiszedés. Ezen lehetne javítani, mivel ennél a 6 megás fájlnál is eltartott egy darabig mire lefutott. Főleg az összepárosítgatós rész tartott sokáig. Nagy vonalakban abból áll, hogy kiszedem a hosszúsági és szélességi koordinátákat és magát az id-t amire hivatkoznak majd az utak. Valamint az utaknak az összes referenciáját külön. Itt még ha nagyon akarunk gyorsítani anélkül, hogy ezen változtatnánk előre foglalhatunk le üres helyeket a vektornak, de ez a része a programnak egyáltalán nem vészes teljesítmény terén.
</para>
<programlisting language='c++'>
<![CDATA[
	while (getline(raw, line))
	{
		if (line.find("node id") != std::string::npos)
		{
			points.push_back({ extract(line, "\""), extract(line, "lat=\""), extract(line, "lon=\"") });
		}
		else if (line.find("nd ref") != std::string::npos)
		{
			tempv.push_back(extract(line, "nd ref=\""));
		}
		else if (!(tempv.empty()))
		{
			references.push_back(tempv);
			tempv.clear();
		}
	}]]>
</programlisting>
<para>
Maga a függvény, amivel lekérem a hosszúságot és a szélességet, valamint. Ezt a függvényt lehtne úgy is meghívni, hogy rövidebb illesztést nézzen, de mivel nem volt hosszú a futása, így nem nagyon erőlködtem, hogy külön adjak még a kezdő pozicíóhoz számot, mert így a search.length() - 1 is jó lesz és borzasztó "megerőltető" lett volna az a + valamilyen nagyságú szám.
</para>
<programlisting language='c++'>
<![CDATA[
std::string extract(const std::string& input, const std::string& search)
{
	std::string output;
	std::size_t from = input.find(search) + search.length() - 1;
	while (input[++from] != '"')
	{
		output += input[from];
	}
	return output;
}]]>
</programlisting>
<para>
Ezután már csak össze kellet párostani a referenciákat a megfelelő koordinátákkal, ami elég sokáig tartott és igen valószínű van rá jobb megoldás. Itt igazából jó lett volna tudni, hogy rendezett vagy rendezetlen listáról van szó id szerint. Mivel így egy lineáris kereséssel oldottam meg, amit nyílván bináris kereséssel mondjuk fel lehetett volna oldani. Vagy maga az id beolvasákor kiosztani egy új id-t és pl egy map használatával letárolni a régit és az újat és az alapján megkapni a koordinátákat. De az legjobb az lett volna, ha sorba vannak és nincs is nincs is benne szakadás mert, akkor csak egy konstanst kellet volna kivonni, ahhoz, hogy megkapjam a megfelelő adatokat. Szóval igen nem a legjobb megoldás, lett volna számos jobb, de végülis működött csak időbe került.
</para>
<programlisting language='c++'>
<![CDATA[
	for (unsigned int i = 0; i < references.size(); i++)
	{
		for (unsigned int j = 0; j < references[i].size(); j++)
		{
			getPointIndex(references[i][j], points, lat, lon);
			coordinates << lat << " " << lon << std::endl;
		}
		coordinates << "\n";
	}]]>
</programlisting>
<para>
Itt még üres sorral választottam el az utakat és úgy írtam ki egy fájlba, de később rájöttem, hogy ez felesleges. Mivel amit én akarok az az, hogy egybe át lehessen küldenia GPU-nak és csak tömb egy indexétől számítva adott számú koordináták apalján rajzoljon ki egy vonalat.  És akkor át is térhetünk az opengl részére, hogy hogyan lesz befejezve a program.
</para>
<para>
Itt egy eléggé nem ajánlott megoldást alkalmaztam az adatok "beolvasására". Az első tömb tartalmaza a koordinátákat, míg a második a kezdő indexet és a hosszúságát az útnak. Viszont ahelyett, hogy beolvastam volna a fájlokat hagytam, hogy a preprocesser kisegítsen, mivel lényegében itt nem fog más történni, mint a két txt tartalma bemásolódik az include helyére. És mivel ott {} között vesszővel vannak felsorolva, így valid kód lesz belőle, csak nem egyértelmű és maga a visual studio se szerette annyira. De itt érdemes rendesen fájlból beolvasni mert és akár ez történhet több threaden is és a végén bevárni, hogy mindegyik be legyen olvasva. Valamint érdemes ezeket az adatokat a heap-en tárolni, mivel ezek a fajta adatok elég hamar nagyok tudnak lenni.
</para>
<programlisting language='c++'>
<![CDATA[
	float positions[] =
#include"poPoints.txt"
		;
	unsigned int indexes[] = 
#include"poIndexes.txt"
		;]]>
</programlisting>
<para>
Maga a kiíratás úgy néz ki, hogy átadjuk az összes koordinátát és megmondjuk index alapján, hogy mit szeretnénk a glDrawArrays paraméterei szeint, amik nem mások, mint, hogy mit szeretnénk rajzolni. Vonal, háromszög stb... Hanyas számú indextől kezdődik a rajzolás a megadott tömbben. Valmint, hogy hány elemét figyelje a tömbnek.
</para>
<programlisting language='c++'>
<![CDATA[
		for (int i = 0; i < 32; i++)
			glDrawArrays(GL_LINE_STRIP, indexes[i++], indexes[i]);]]>
</programlisting>
<para>
Ez mind szép és jó, de ha ezt csak így simán futattnánk semmit se látnánk. Mivel alapértelmezetten opengl -1 és 1 között dolgozik. De persze erre is van megoldás glm könyvtár formájában vagy igazából akármilyen megoldás jó, csak kicsit szoroznunk kell.
</para>
<para>
Tehát létrehozunk egy mátrixot, amiben megadjuk, hogy milyen pontokat szerenénk, majd azt a vertex shaderen belűl összeszorozzuk, így a koordináták is a megfelelő helyre fognak kerülni.
</para>
<programlisting language='c++'>
<![CDATA[		glm::mat4 proj = glm::ortho(475308671.0f, 475998139.0f, 216029324.0f, 216602269.0f, -1.0f, 1.0f);
		glm::mat4 mvp = proj;
		glUniformMatrix4fv(glGetUniformLocation(shader, "u_MVP"), 1, GL_FALSE, &mvp[0][0]);]]>
</programlisting>
<para>
Itt a fenti kódrészletben az ortho függvény adja meg, azt, hogy milyen tartományon belűl szeretnénk "látni". Leegyszerűsítve ott adjuk meg az x és y tengely kezdő és végértékeit. Ez úgy néz ki, hogy a vertex shaderben a vertex koordinátája össze lesz szorozva a projection mátrixxal és ezért a koordináták "jó" helyre fognak kerűlni. Ezt úgy érjük el, hogy a már említett projection mátrix bekerűl az mvp-be, aminek most a neve nem releváns. És ennek a mátrixnak a kezdő koordinátáját átadjuk az u_MVP nevű unoformnak, ami össze lesz szorozva vertex koordinátáival. Itt én a minimum és maximum értékeket a projection mátrixnál aszerint választottam, hogy mi volt a legnagyobb és legkisebb érték x és y tengelyre nézve, szóval kisebb torzulások előfordúlhatnak, mivel maga az ablak mérete 720p-s.
</para>
<para>
És ezek után mostmár látnunk kéne az első 16 utat, ami a debreceni régión belűl található az OSM adatbázisában. De helyette egy ilye szépséget kaptam.
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/OSCI3_meh.png" scale="50" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
Ez nem annyira hasolít egy város utcáinak felűlnézeti rajzára. De valószínűleg a kezdő indexekkel lesza a baj az éles váltásokból következtetve. Mivel így egy ponttal később kezz el rajzolni egy ugyanolyan hosszú pontot és az utolsó koordináta már a következő úthoz tartozna. Szóval valahol a kinyert koordinátákat tartalmazó fájl módosításai közben elírtam valamit és rosszúl adtam vissza a kzedő koordinátát. Korigálás után pedig így néz ki.
</para>
<figure>
<title></title>
<mediaobject>
<imageobject>
<imagedata fileref="img/OSCI3_kinda.png" scale="50" />
</imageobject>
<textobject>
<phrase></phrase>
</textobject>
</mediaobject>
</figure>
<para>
Ez már elég közel áll ahhoz, amit elterveztem. Nyílván ehhez az kéne, hogy ne a stacken tároljam azt a pár adatot, de szerintem a feladat már ezzel is elkönyvelhető. És mivel érdemes lenne átírni, több fájlba, hogy átláthatóbb legyen ne egy nagy maszlag az egész kód, így az itt tapasztaltak alapján már a következő opengles programhoz ezzel a tudással állok neki.
</para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
</chapter>                
