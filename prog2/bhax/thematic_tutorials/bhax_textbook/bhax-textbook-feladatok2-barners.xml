<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Berners-Lee!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Szoftverfejlesztés C++ nyelven</title>

<!-- 1-16 -->
<para>
C-ben ha a nem adunk meg függvényparamétert, akkor az azt jelenti, hogy neki tetszőleges lehet , míg c++ ez azt jelenti, hogy nincs neki. Ha mégis tetszőleges számú paraméterrel akarunk természetesen az is megoldható. További különbség, hogy c-ben nincs logikai változó, hanem ott int értékkként kezeli, míg c++-ban van külön logikai változó. C++ lehetőség van függévnyek túlterhelésére is, ezt úgy érhetjük el, hogy azonos néven, de különböző paraméterszámmal deklarálunk függvényeket. Így igazából a forráskódban ugyanaz a nevük de a linker majd megváltoztatja azt. Adhatunka függvényeknek alapértelmezett értéket is. Paraméterátadást végezhetünk referencia szerint, ez azt jelenti, hogy ilyenkor nem készül a híváson belűl egy másolat az átadott paraméterről, hanem azt a címet kapja meg, ahol a változó van tárolva.
</para>
<!-- 17-59 -->
<para>
Az objektumorientált programozás, hasonló a való élethez, mivel megengedi az osztályok használatát. Eze lényege az, hogy létrehozhatunk egy mintát. Példáúl egy osztályba leírjuk, hogy milyen egy banszámla és ezt az osztályt példányosíthatjuk, akár különböző értékekkel. Az osztályok továbbá lehetőségetadnak, az adatok elrejtéséreí így kívűlről nem lehet eldönteni, hogy mi van az osztály belsejében, ha szeretnénk. Az osztályok örökölhetnek egymástól. Példáúl ha B osztály örököl A osztálytól, akkor B-nek lesznke olyan részei, ami teljesen A-tól származik és, ehhez még hozzájön, hogy B-t hogyan szeretnénk még pontosabbá tenni. Igazából az osztályok olyanok mint egy továbbgondolt struktúra, mert példáúl, ha stuktúrában létrehozunk egy koordináta rendszert, akkor csak a struktúrán kívűl lehet létrehozni függvényt, ami használja azon értékeit. De az osztály használatával ez a probléma megszűnik, mivel függvénykeket is deklarálhatunk benne. Ha adatookat szeretnénk elrejteni, akkor azt a private szóval thetjük meg, ez annyit tesz, hogy az osztályon kívűl nem lehet elérni a változókat/függvényket. Ha azt szeretnénk, hogy elérhető legyen akkor a public  kulcsszót kell használnunk. Az osztályokat a konstruktor hozza létre, amit mi is deklarálhatunk magunktól. Ehhez nem kell mást tennünk, mint az osztály nevével létrehozunk egy függvényt. A konstruktor akkor fut le, amikor az osztályból készül egy példány és itt lehet megadni, hogy hogyan mit csináljon az osztály létrehozáskor. Példáúl milyen értékei legyenek, írjon-e ki vaalmit esetleg az osztályon kívűl csináljon valamit vagy hívjon-e meg függvényt stb. A destruktor hasonló a konstruktorhoz, de ez akkor fut le, amikor az adott példány befejezte életét. Ezt is meg lehet adni ugyanúgy mint a konstruktort, de előtte használni kell a ~ jelet. Létezik még másoló konstruktor is, amit arra használunk, hogy osztályok értékeit másoljuk át egy új osztályba. Ezt magunk is megadhatjuk, de ha az osztályban nincs mutató felesleges, hacsak nem akarunk még valami plusz feladatot adni a másoláson kívűl. Mivel a beépített másoló konstruktor addig működik jól, ameddig nem használunk mutatuókat. Korábban említettem, hogy a private szóval lehet adatokat elrejteni, ezzel viszont az a baj, hogy ilyenkor az osztály nem örökli a private-ként megjelölt részeket. Ha mégis szeretnénk, hogy valamennyire legyeenk elrejtve az adatok és mégis tudjanak örökölni, akkor azt a friend kulcsszóval tehetjük meg. Továbbá lehetőség van static kulcsszóval olyan változót deklarálni, ami minden osztályban ugynaaz lesz és nem tagváltozóként fog létrejönni, hanem egy közös memóriacímen. Viszont ezt tagfüggvényekkel nem oldhatjuk meg. Végül ha nagyon szeretnénk, használhatunk beágyazott definíciót, ami nem tesz mást mint hogy más névvel tudunk adott dolgokra hivatkozni.
</para>
<!-- 93-96 -->
<para>
Az operátor túlterhelés annyit tesz, hogy a már létező operátorok működését megváltoztathatjuk. Ezt a legegyszerűbben talán másoló értékadással lehet elmagyarázni. Ha már létrehoztunk egy osztályon belűl egy másoló konstruktort, akkor az akkor fog lefutni, ha példányosítjuk és akkor adjuk meg az értékét. De ha már van egy példányunk és azt szeretnénk egy egyenlővé tenni egy másik osztály értékeivel ezt is megoldható. Ehhez nem kell mást tenni mint kiválasztani egy operátort és túlterhelés során hozzáírni a másoló konstruktor lépésit. Példáúl alapesetben az = jel osztályok esetén nem jelent sok mindent, de ha az előbb leírtak alapján túlterhejük akkor működni fog.
</para>
<!-- 73-90 I/O -->
<para>
A c++ több féle adatfolyamot különböztet meg. Létezik standard bemenet, standard kimenet, hiba kimenet és log kimenet. Ezek szerintem maguktól értetődnek, hogy melyik micsoda. Persze ezeket lehet variálni, hogy hogyan hogyan működjenek. Fájlműveleteket az fstream segítségével tudunk elvégezni. Itt van egy pár lehetőség, hogy hogyan nyissuk meg vagy hogy egyáltalán mit akarunk a fájllal.
</para>
<!-- 187-197 -->
<para>
Előfordulhat, hogy a program futása során hibakezeléssel kell foglalkoznunk, mert azt akarjuk, hogy valami bizonyos értékkel fusson le vagy csak mert a kódban van olyan rész, ami hibát eredményezhet. Ez lehet példáúl egy számológép esetén 0-val való osztás, ami kifog a cpu-n. Ezen problémák kezelésére tökéletes a try catch blokkok. Ez úgy működik hogy egy try blokkba belerakjuk, azt a kódot, ami hibához vezethet és ha valóban hibát okoz, akkor rögtön ugrik a catch részre, már amennyiben úgy adtuk meg, hogy mindent kapjon el vagy bizonyos kivételeket. Végrehajtja ami ott van és fut tovább a program mintha misem történt volna. Ha példáúl azt akarjuk, hogy beolvasás folyamán bozonyos értéket ne lehessen ezt úgy thejük meg, hogy után throw-al dobunk egy hibát és így ismét a catch rész fog lefutni.
</para>
<!-- 190 197 211 példák -->
    </section>        
    <section>
        <title>Java útikalauz programozóknak 5.0</title>
<para>
A java nyelv ugyanúgy objektum orientált programozási nyelv mint a c++ és ezért mindkét nyelv ugyanazt a progrtamozási gondolkozást igényli. A két nyelv szintaxisa is elég hasonló. A fontosabb különbségek közé tartozik az, hogy java nem használ pointereket. Helyette mindent referenciaként kezel. C++-hoz hasonlóan itt is van egy main függvény, ami a program indításakor kerül először futattásra, de ehhez java esetén még kötelező a static kulcszót használni. A static igazából csak annyit csinál, hogy nem engedi példányostani, van egy verziónk belőle és kész. Ami még szembetűnő az, hogy java forráskód esetén fordítás után szükség van egy külön programra, hogy a kódunkat tudjuk futattni. Ennek az az oka, hogy míg c++ esetén a compiler gépi kódra fordít, addig java esetén egy köztes nyelvre, amit a a java virtuális géppel tudunk futattni. Ennek az az előnye, hogy így elég egyfajta forráskódot megírnunk, mivel a virtuális gép gondoskodik róla, hogy minden platformon ugyanúgy működjön a kódunk, ahogy mi azt eltervetük.         
</para>
<para>
Változókat tekintve, ha az alap típusokat nézzük illeetve, hogy hogyan tudjuk azokat deklarálni/értéket adni nekik, akkor elmondhatjuk, hogy ugyanúgy működik mint c++ esetén. Ami viszont érdekesebb, hogy javaban nem lehet az operátorokat túlterhelni, csak a függvényeket. Ugyanazokkal a feltételekkel, mint c++-ban, azaaz különböző attribútum számúnak kell lennie és/vagy különböző típusú attrbútomokat kérjen. Java esetén, ha konstansokkal szeretnénk dolgozni, akkor azt a final kulcsszóval tehetjük meg. A konstansok nem mások mint nevesített értékek. Akkor érdemes őket használni, ha van érték, ami többször is előfordul a program írása során és az értke mindig megyegyezik. Erre kitűnő példa például a pi értéke. Előfordúlhat, hogy többször is szükségünk lesz rá a program futása során és ilyenkor egyszerűbb egy konstanst használni. Java esetén ugyanúgy lehet használni a kommenteket mind c++ esetén, vagyis // az egysoros és /* szöveg */ a többsoros komment. Azonban létezik mégegy fajta komment javaban /** szöveg */ ez esetben ugyanúgy figyelmen kívűl hagyja a kódot, de a dokumentációban meg fog jelenni. Illetve érdemes megjegyezni, ezt a fajta kommentet akármennyi * jellel fel lehet dúzasztani.
</para>
<para>
Nem meglepő módon javaban az osztályok is meglehetősen hasonlóan működnek. A lényegesebb eltérések öröklődés esetén jönnek be. Valamint példányosítás során használnunk kell a new kulcssszót, hogy a memóriában fogalaljon helyet a változóknak. Osztályok metódusait hasonlóan kell megadni mint c++ esetén. Annyi eltérés viszont van, hogy itt a metódus elején kell megadnunk, hogy milyet szeretnénk public, private, protected, de ezt leszámítva ugyanaz a szintaxisa. Mint c++ esetén itt is van lehetőség kivételkezeésre try catch blokk használtával, ami igazából megint mondhatni teljesen megegyezik. Az itt lévő jelentősebb különbség az, hogy ha szeretnénk kivételt dobni a throw kulcsszóval az szintaxisában kicsit eltérő, de ugyanúgy működik. A kivételkezelés amúgy akkor fontos, ha olyan kódot akarunk futattni, ami hibához vezet. Példáúl ha két számot osztunk és egy felhasználótól kértünk be számokat, akkor figyelnünk kell rá, hogy a nullával való osztás hibához fog vezetni. Ezért ezt a részt belerakjuk egy try blokkba és ha a program futása során hiba történt, akkor azt a catch blokk el fogja kapni és nem fog leállni a programunk.
</para>
<para>
A java programozási nyelv ugynúgy mint c++ megadja a lehetőségét, annak, hogy többszálon futó programokat írjunk. Java esetén kétféleképpen lehet új szálat létrehozni. Vagy a Thread osztályt örököljük és a megfelelő dolgokat megváltoztatva már a run metódus eghívásával létre is hotuk az új szálat, vagy pedig haszálhatjuk a runnable interface-t, annak érdekében, hogy új szálat hozzunk létre. Valamint lehetőség van állítani az egyes szálaknak a prioritását egy egytől tízes skálán, ahol az alapértelmezett érték az 5.
</para>
    </section>        
    <section>
        <title>Bevezetés a mobilprogramozásba</title>
<para>
Kedves naplóm elolvastam a könyv pythonra vonatkozó részét, ami azért volt csodás, mert rengeteg új tudásra tettem szert ezzel a viszonylag új programozási nyelvvel kapcsolatban. Python egy magasszintű programozási nyelv, amit előszerettel használnak prototípúkészítésre, mivel elképesztően gyorsan lehet benne kódokat írni. Valamint maga a nyelv szintaxisa is egyszerű, ami azt eredményezi, hogy a tanulási fázisa meglepően rövid. Valószínűleg ez okból és azért mert gyorsan lehet látványos szintre jutni rengeteg függvénykönyvtár található hozzá. A programoozási nyelv amúgy egy interpreteres nyelv, ami annyit tesz, hogy nincs meg a szokásos forráskód fordítás ciklus mint más nyelveknél és így erre nem is kell várni mivel az interpreter egyből tudja olvasni a python "szkriptet". Python egy igazán hasznos jellemzője továbbá még az is, hogy jól lehet vele használni más nyelven írt modulokat így megnövelve a produktivítást. Ez allat az értendő, hogy a programunknak van egy része, ami elég erősen erőforrás igényes azt például megírhatjuk c++-ban és optimalizálva azt a részt. A c++ modult pedig pythonnal együtt tudjuk használni. Rengeted AI kutatás használja ezt a módszert, ahol maga a az AI core funkciói c++-t használva vannak megírva viszont pythont használva fel lehet gyorsítani a fejlesztést, mivel gyorsan lehet kódokat írni és ez kárpótol a gyengébb teljesítményért.
</para>
<para>
A python nyelv szintaxisa meglehetősen egyszerű/könnyen olvasható. Példáúl nincs sorok végén ; mint java vagy c/c++ esetén helyette az új ugyanezt a funkciót tölti be. Ha mindenesetben egy sorban szeretnénk két statement-et akkor az új sor helett tabot is használhatunk. Jelentős különbség még az is, hogy példáúl egy függvény esetén, ha azt szeretnénk, hogy maga a függvény törzse több sorból/utasításból álljon, akkor { } közé kellet írnunk a kódokat számos más programozási nyelv esetén. Ez python esetén annyiból áll hogy ezt a kódblokkot elég ha csak beljebb kezdjük. Ezt megtehetjük tab használatával vagy szóközökkel. Ez eleinte szokatlan lehet, de igazából ennek és az előző tulajdonságnak köszönhetően a python forráskód olvasása hatalmasat nő.
</para>
<para>
Egy másik sajátossága magának a nyelvnek, hogy habár létezik több változótípus magában a nyelvben azokat automatikusan osztja ki mondhatni kitalálja, hogy milyen változónak amúgy mi is a típusa. Továbbá a változótípusok közötti konverziót is automatikusan kezeli, ami kezdő programozóbaráttá teszi. Maga nyelv olyan téren, hogy milyen típusokat ismer nem mútat semmi újat. Ez alatt azt értem, hogy javaban példáúl megtalálható a pythonban jelenlévő összes típus. Ezek a számok, karakter/karakterlánc, tömbök stb... Hasonlóan javahoz python esetén is a már nem használt szemetet a garbage collector rendezi, így a memóriakezeléssel sem kell foglalkozni. Python esetén is léteznek globális és lokális változók. Függvényen belűl a változók lokalásik, de ha globálissá szerertnénk tenni, akkor azt a global kulcsszóval megtehetjük.
</para>
<para>
For ciklus python esetén a java féle enhanced for loopnak felel meg vagy C# esetén for each-nek. Ennek igazából csak annyi jelentőssége van, hogy az itt lévő for loopokkal tömbökön tudunk iterálni egyesével. Ha viszont minden esetben szeretnénk mondjuk 1-től 100-ig eljutni egytől eltérő lépéközzel, akkor előbb egy olyan tömböt kell létrehoznunk, ami azokat a számokat tartalmaza, hogy később azon egyesével végig tudjunk menni. Szerencsére range() használatával az összes ilyen jellegű problémát könnyen lehet orvosolni. Mivel python is OOP szemléletet követi, így lehetőség van függvények és classok definiálására a megfelelő kulcsszó használatával. Nem meglepő módon itt is lehetőségünk van hibakezelésre, amit a try except kulcsárossal tudunk elérni. Ez igazából nem szorúl sok magyarázatra, mivel mondhatni ugyanúgy működik mint a try catch java/C++ esetén. Amit érdemes megemlítenni hogy a finally kulcszóval lehetőség van egy kódot lefuttatni mindenképpen, attól függen hogy volt-e kivétel. Ha volt akkor előbb az except blokk fut le majd a finally. Ez akkor lehet lényeges, ha egy fájlba akarunk írni vagy onnan olvasni és közben valamiféle hiba történik, így a finally részben kérhetjük, hogy csuklya be a fájlt.
</para>
    </section>        
</chapter>                
